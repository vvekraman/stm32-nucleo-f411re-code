// BLINKING USER LED (LD2)
// PORT: A
// PIN : 5
// Clock supplied via AHB1 100MHz (refer block diagram)

// APB: Advanced Peripheral Bus
// AHB: Advanced High Performance Bus
//(AHB can access for example a GPIO in fewer clock cycles)

#include <stdint.h>

#define PERIPH_BASE			(0x40000000UL)
#define AHB1_PERIPH_OFFSET	(0x00020000UL)
#define AHB1PERIPH_BASE		(PERIPH_BASE + AHB1_PERIPH_OFFSET)
#define GPIOA_OFFSET 		(0x0UL)

#define GPIOA_BASE			(AHB1PERIPH_BASE + GPIOA_OFFSET)

// RCC: Resetting Clock Control (enable clock access to GPIOA)
#define RCC_OFFSET			(0x3800UL)
#define RCC_BASE			(AHB1PERIPH_BASE + RCC_OFFSET)

// Shift the bit at position 0 to 1
#define GPIOAEN				(1U<<0)

// finding the registers in the GPIOA
// usually GPIO in microcontrollers have atleast 2 registers
// direction and data register
// direction register -> sets the pin to either input or output
// data register -> to store data, if its input, then it stores data
// if its output, the data we have to send out flows via data register
// depending on the microcontroller make, the direction register
// will have different names
// in STM32 it's MOD register
// we use the MOD register to set the GPIO direction to output
// and the data to send out is stored in the data register

// In MODER as per ref-manual, set bit 10 to 1 and bit 11 to 0
// to configure the I/O direction as general purpose output mode
// i.e, set bit 10 to 1 and bit 11 to 0 -> (1U<<10) and &=~(1U<<11) (shorthand)
// We need pin 5, so MODER5
#define PIN5				(1U<<5)
#define LED_PIN				 PIN5


// Struct for RCC
typedef struct
{
	volatile uint32_t DUMMY[12];
	volatile uint32_t AHB1ENR;
} RCC_TypeDef;


// Struct for GPIO
// To blink the LED, we have to write to the output data register
// which would be the GPIOx_ODR - output data register
typedef struct
{
	volatile uint32_t MODER;
	volatile uint32_t DUMMY[4];
	volatile uint32_t ODR;
} GPIO_TypeDef;


#define RCC		((RCC_TypeDef*) RCC_BASE)
#define GPIOA	((GPIO_TypeDef*) GPIOA_BASE)


int main(void)
{
	// enable clock access to GPIOA
	// |= sets only the bit to change (friendly programming)
	RCC->AHB1ENR |= GPIOAEN;

	// set PA5 as output pin
	GPIOA->MODER &=~(3U<<10);	// Clears bit 11:10
	GPIOA->MODER |= (1U<<10);	// Set bit 10 to 1

	while (1)
	{
		GPIOA->ODR |= (1U<<5);
		for(int i=0; i<100000; i++){}

		GPIOA->ODR &= ~(1U<<5);
		for(int i=0; i<100000; i++){}

		GPIOA->ODR |= (1U<<5);
		for(int i=0; i<500000; i++){}
	}
}
