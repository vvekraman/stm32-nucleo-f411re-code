// BLINKING USER LED (LD2)
// LED @ PORT: A | PIN : 5 (PA5)
// BUTTON @ PORT: C | PIN : 31 (PC13)

#include <stdint.h>
#include "stm32CustomHeader.h"

#define PERIPH_BASE			(0x40000000UL)
#define AHB1_PERIPH_OFFSET	(0x00020000UL)
#define AHB1PERIPH_BASE		(PERIPH_BASE + AHB1_PERIPH_OFFSET)
#define GPIOA_OFFSET 		(0x0UL)
#define GPIOA_BASE			(AHB1PERIPH_BASE + GPIOA_OFFSET)
#define GPIOC_OFFSET 		(0x800UL)
#define GPIOC_BASE			(AHB1PERIPH_BASE + GPIOC_OFFSET)

// RCC -> Resetting Clock Control (enable clock access to GPIOA)
#define RCC_OFFSET			(0x3800UL)
#define RCC_BASE			(AHB1PERIPH_BASE + RCC_OFFSET)

// Shift the bit at positions to 1
#define GPIOAEN				(1U<<0)
#define GPIOCEN				(1U<<2)

// LED and BUTTON pins
#define PIN5				(1U<<5)
#define LED_PIN				 PIN5
#define PIN13				(1U<<13)
#define BTN_PIN				 PIN13

// calling structs
#define RCC		((RCC_TypeDef*) RCC_BASE)
#define GPIOA	((GPIO_TypeDef*) GPIOA_BASE)
#define GPIOC	((GPIO_TypeDef*) GPIOC_BASE)

int main(void)
{
	// enable clock access to GPIOA
	// |= sets only the bit to change (friendly programming)
	RCC->AHB1ENR |= GPIOAEN;
	RCC->AHB1ENR |= GPIOCEN;

	// set PA5 as output pin
	GPIOA->MODER &=~(3U<<10);	// Clears bit 11:10
	GPIOA->MODER |= (1U<<10);	// Set bit 10 to 1

	// MODER 13 -> bit 26, 27 to 0 for input (PC13 button)
	GPIOC->MODER &=~(1U<<26);
	GPIOC->MODER &=~(1U<<27);

	while (1)
	{
		if (!(GPIOC->IDR & BTN_PIN)) {GPIOA->ODR |= LED_PIN;}
		else{GPIOA->ODR &=~ LED_PIN;}
		//for (int i=0; i<10000; i++){}

	}
}
